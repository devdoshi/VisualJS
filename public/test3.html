<html>
    <!-- HMTL Headers and iclude all external JS scripts and stuff -->
    <head>
        <meta http-equiv="X-UA-Compatible"  content="IE=edge" />
        <meta name="viewport"    Content-Type="text/javascript; charset=utf-8" content="initial-scale=1.0, width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        <meta charset="UTF-8" />


        <!-- JS libraries and where they come from originally -->
        <linkfrom       rel="stylesheet" href="https://cdn.usebootstrap.com/bootstrap/4.1.3/css/bootstrap.min.css"></linkfrom>
        <scriptfrom     src="https://unpkg.com/vue@3.4.21/dist/vue.global.js">                                  </scriptfrom>
        <scriptfrom     src="https://cdn.jsdelivr.net/npm/alasql@4">                                            </scriptfrom>
        <scriptfrom     src="https://cdn.jsdelivr.net/npm/acorn@latest/dist/acorn.min.js">                      </scriptfrom>


        <!-- Locally cached copies of the external JS libraries (so that we can do development offline) -->
        <link       rel="stylesheet" href="/js_libs/bootstrap4.1.3.css">                                    </link>
        <script     src="/js_libs/vue.global.js">                                                           </script>
        <script     src="/js_libs/alasql4.js">                                                              </script>
        <script     src="/js_libs/acorn.min.js">                                                            </script>


        <!-- JS lib that only works Inline in the HTML -->

        <style>
        .ace_gutter-cell.ace_breakpoint{
        border-radius: 20px 0px 0px 20px;
        /* Change the color of the breakpoint if you want */
        box-shadow: 0px 0px 1px 1px #248c46 inset;
        }
        </style>

        <style>
            .highlight {
                background-color: yellow;
            }
            .hint {
                display: none;
                position: absolute;
                background-color: #333;
                color: white;
                padding: 5px;
                border-radius: 3px;
                z-index: 1000;
            }
            .highlight-character {
                background-color: gray;
                position: absolute;
                z-index: -2000;
            }
        </style>
        <style>
            /* Custom CSS to change the active line highlight color */
            .ace_editor .ace_marker-layer .ace_active-line {
                background: lightblue /* Yellow highlight with 30% opacity */
            }
        </style>
    </head>

    <!-- Start of the HTML to host the main Vue app -->
    <body>
        <div style="margin-top:20px">
            <div id="vue_root_element"></div>
        </div>
    </body>

    <!-- Start of all code in the script tag-->
    <script>
        async function  init                                (  )                                                {
            await useIdeTools()
        }
        function        alaSqlStuff                         (  )                                                {
            alasql("CREATE TABLE test (language INT, hello STRING)");
            alasql.fn.verify = function(r) {
                return true; // Do not insert on this number
            };
            alasql('CREATE TRIGGER mytrigger BEFORE INSERT ON test verify');
            alasql("INSERT INTO test VALUES (1,'Hello!')");
            alasql("INSERT INTO test VALUES (2,'Aloha!')");
            alasql("INSERT INTO test VALUES (3,'Bonjour!')");
            console.log( alasql("SELECT * FROM test WHERE language > 1") );

            alasql("create view testview (name) as select * from test ;")
            alasql.fn.verify2 = function(r) {
                return true; // Do not insert on this number
            };
            alasql('CREATE TRIGGER mytrigger AFTER update ON testview verify2');
            alasql("INSERT INTO test VALUES (4,'Velkommen!')");
            console.log( alasql("SELECT * FROM testview ") );
        }
        async function  useIdeTools                         (  )                                                {
            let promise = new Promise(returnfn => {
                let loadIdeToolsLibScript = document.createElement('script');
                loadIdeToolsLibScript.src = "/js_libs/idetools.js";
                document.head.appendChild(loadIdeToolsLibScript);
                loadIdeToolsLibScript.onload = function () {
                    try {
                    } catch (error) {
                    }
                    returnfn()
                };
            })
            let ret = await promise
        }
        function        createDebuggerUI                    (  )                                                {
            vueApp = Vue.createApp({
                template:                       `
<div style="margin: 20px; font-size: 11px;">
    <div>

        <span style="width:45%; margin-right: 20px; height: 80%;">
            <!--  The CANNED PROGRAM HTML SELECTOR  -->
            <select v-on:change='selectProgram()'  v-model="selectedProgramIndex">
                <option v-for='(opt,index) in defaultPrograms'
                        v-bind:selected='selectedProgramIndex == index'
                        v-bind:value='index'>
                    ({{index}}) {{opt.name}}
                </option>
            </select>
            <br/>

            <!--  The PROGRAM TEXT EDITOR  -->
            <div id="timeline_editor_html_element"></div>
            <div id="hint" class="hint">This is a hint!</div>
        </span>

        <span  v-if="!rightPane" style="width:45%;display: inline-block; border: 1px solid black; vertical-align: top;height: 50%;" id="preview" >No preview</span>

        <span  v-if="rightPane=='AST'" style="width:49%;display: inline-block; border: 1px solid black; vertical-align: top;height: 50%;" id="preview" >
            <b>AST</b>
            <pre style="overflow: scroll;height:95%">{{codeAST}}
            </pre>
        </span>

        <span  v-if="rightPane=='canvas'" style="width:49%;display: inline-block; border: 1px solid black; vertical-align: top;height: 50%;" id="preview" >
            <b>Canvas</b>
            <canvas id=canvas style="overflow: scroll;height:95%">

            </canvas>
        </span>



    <div style="margin-top: 20px;">
        <button   v-on:click="runCode()"
                  type="button"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Run
        </button>

        <button   v-on:click="createAST()"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Code -&gt; AST
        </button>

        <button   v-on:click="transformAST()"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Transform AST
        </button>

        <button   v-on:click="createDebugCode()"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            AST -&gt; Code
        </button>

        <button   v-on:click="startDebugger()"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Start Debugger
        </button>



        <!-- ----------------------------------
                    RESUME DEBUGGER
             ---------------------------------- -->
        <button   v-on:click="resumeDebugger()"
                  v-if="rightPane=='debugger'"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Resume
        </button>

        <!-- ----------------------------------
                    STEP BACK IN TIME - not implemented yet
             ---------------------------------- -->
        <button   v-on:click="stepBack()"
                  v-if="rightPane=='debugger'"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            &lt;
        </button>

        <!-- ----------------------------------
                    STEP OVER CODE
             ---------------------------------- -->
        <button   v-on:click="stepOver()"
                  v-if="rightPane=='debugger'"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            &gt;
        </button>



        <!-- ----------------------------------
                    STOP DEBUGGER
             ---------------------------------- -->
        <button   v-on:click="stopDebugger()"
                  v-if="rightPane=='debugger'"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Stop Debugger
        </button>


    </div>


    <div  style="padding:5px;margin-bottom:5px;"
          v-if="rightPane=='debugger'">

        <!-- ----------------------------------
                 EVAL AT BREAKPOINT
             ---------------------------------- -->


        <input size=100 v-model="codeToEvalAtBreakpoint" style="margin-right:10px;"></input>

        <button   v-on:click="evalAtBreakpoint()"
                  style="margin-right: 10px;"
                  class="btn btn-sm btn-info">
            Eval
        </button>

        <span>Result: {{breakpointEvalResult}}</span>
    </div>

    <br/>
    <div style="border: 3px solid red">{{error_msg}}</div>



    <pre id=debug_steps style="height:250px; overflow-y:scroll">
programDebugSteps:
{{programDebugSteps}}
    </pre>

    <pre>
lastDebugSteppedIndex:
{{lastDebugSteppedIndex}}

runToDebugStepIndex:
{{runToDebugStepIndex}}

listOfBreakpoints:
{{listOfBreakpoints}}

nextLineToExecute:
{{nextLineToExecute}}
    </pre>
</div>                         `,
                data:                           function        (  )                        {
                    return {
                        programDebugSteps:          [  ],
                        lastDebugSteppedIndex:      -1,
                        runToDebugStepIndex:        null,
                        rightPane:                  "canvas",
                        codeToEvalAtBreakpoint:     null,
                        evalCodeAtBreakpoint:       null,
                        breakpointEvalResult:       null,
                        pauseAtNextLine:            false,
                        listOfBreakpoints:          {  "1": true },
                        listOfSyncAsyncLines:       {},
                        listOfSyncCallbackLines:    {},
                        nextLineToExecute:          null,
                        error_msg:                  refErrorMsg,
                        codeAST:                    null,
                        transformedAST:             null,
                        selectedProgramIndex:       3,//3 for Vue
                        defaultPrograms:            [
                            {
                                name: "Console log",
                                code:
                                    `let a = 1
console.log("out: " + a)
a++
console.log("out: " + a)
a++
console.log("out: " + a)
a++
console.log("out: " + a)
a++
console.log("out: " + a)
let af = async function() {
    console.log("out: 6" )
    //return 7
}
let retres = await af()
console.log("out: " + retres)
console.log("out: 8")
`
                            }
                            ,
                            {
                                name: "JS Function",
                                code:
                                    `function a() {
    let re = 1+2+3
    return re
}

console.log("val = " + a())`
                            }
                            ,
                            {
                                name: "Assignment",
                                code:
                                    `let a = 1
                                    `
                            }
                            ,
                            {
                                name: "Vue",
                                code:
                            `console.log("out: " + new Date().getTime())
let a = 1
a++
let b = a
let c = 1
let vueDebugApp = await Vue.createApp(
    {
        template:   \`
                    <div style="margin: 20px;">
                        Vue debug app: {{step}}
                        <button type=btn v-on:click=doSomething>Increment</button>
                        <div style="margin: 20px;">
                            <input v-model=debug_message></input>
                            <button type=btn v-on:click=changeMessage>Change</button>
                            <div style="margin: 20px;">Debug: {{debug_message}}</div>
                        </div>
                    </div>
                    \`
                    ,
        methods:    {
            doSomething: async function() {
                this.step = "* Button pressed " + c + " times"
                c++
            },
            changeMessage: async function() {
                this.step = this.debug_message
            }
        },
        data:       function () {
                        return {
                            step: "RETURN data fn in Vue",
                            debug_message: ""
                        }
                    }
            })
let app = await vueDebugApp.mount("#vue_app_element")
app.step = "Changed message"
return {step: "Main app run"}`
                            }
                        ],

                        //DEFAULT CODE TO DEBUG
                        htmlInput: "",
                        debugCode: null,
                        debugCodeToEval: null
                    }
                },
                mounted:                        async function  (  )                        {
                    let mm = this
                    await mm.setupAceEditor()
                    await mm.selectProgram()

                    let c = document.getElementById("canvas");
                    var ctx = c.getContext("2d");
                    ctx.moveTo(0, 0);
                    ctx.lineTo(200, 100);
                    ctx.stroke();
                },
                methods:                        {
                    scrollEnd:                      function        (  )                        {
                        setTimeout(function(){
                            var objDiv = document.getElementById("debug_steps");
                            objDiv.scrollTop = objDiv.scrollHeight;
                        },100)
                    },
                    setupAceEditor:                 async function  (  )                        {
                        let mm = this
                        ace.config.set('basePath', '/');
                        timeline_editor = ace.edit(           "timeline_editor_html_element", {
                            selectionStyle: "text",
                            mode:           "ace/mode/javascript"
                        })


                        //Bug fix: Need a delay when setting theme or view is corrupted
                        setTimeout(function(){
                            timeline_editor.setTheme("ace/theme/sqlserver");
                            timeline_editor.getSession().setMode({
                                inline: true
                            });
                        },100)

                        document.getElementById("timeline_editor_html_element").style["font-size"]   = "11px"
                        document.getElementById("timeline_editor_html_element").style.width          = "40%"
                        document.getElementById("timeline_editor_html_element").style.border         = "0px solid #2C2828"
                        document.getElementById("timeline_editor_html_element").style.display        = "inline-block"
                        document.getElementById("timeline_editor_html_element").style.height         = "50%"

                        timeline_editor.getSession().setValue("");
                        timeline_editor.getSession().setUseWorker(false);
                        //timeline_editor.setReadOnly(true)
                        timeline_editor.getSession().setBreakpoint(0);


                        timeline_editor.on("guttermousedown", function(e) {
                            var target = e.domEvent.target;

                            if (target.className.indexOf("ace_gutter-cell") == -1){
                                return;
                            }

                            if (!timeline_editor.isFocused()){
                                return;
                            }

                            if (e.clientX > 100 + target.getBoundingClientRect().left){
                                return;
                            }

                            var row = e.getDocumentPosition().row + 1;

                            if (!mm.listOfBreakpoints[row]) {
                                mm.listOfBreakpoints[row]  = true
                                e.editor.session.setBreakpoint(row - 1);
                            } else {
                                delete mm.listOfBreakpoints[row]
                                e.editor.session.clearBreakpoint(row - 1)
                            }
                            e.editor.scrollToLine(row , true, true, function () {});
                            //e.stop();


                        });
                    },
                    selectProgram:                  async function  (  )                        {
                        let mm = this
                        this.htmlInput = this.defaultPrograms[this.selectedProgramIndex].code
                        timeline_editor.getSession().setValue(mm.htmlInput)
                        mm.rightPane = "canvas"
                    },
                    runCode:                        async function  (  )                        {
                        let mm = this
                        mm.rightPane = "running"
                        mm.htmlInput = timeline_editor.getSession().getValue()
                        Vue.nextTick(async function () {
                            eval("(async function() {" + mm.htmlInput + "})()")
                        })
                    },
                    createAST:                      async function  (  )                        {
                        let mm = this
                        mm.rightPane = "AST"

                        mm.htmlInput = timeline_editor.getSession().getValue()
                        //debugger
                        mm.codeAST = acorn.parse("(( async function() { " + mm.htmlInput + " })())",{ ecmaVersion: 2021 , locations: true, range: true});

                    },
                    isRunningInAsyncNode:           function        (  node  ,  parent  )       {
                        let mm = this
                        if ((node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') && node.async ) {
                            return true
                        } else {
                            if (parent) {
                                return mm.isRunningInAsyncNode(parent)
                            }
                            return false
                        }
                    },
                    clearUnreachableBreakpoints:    async function  (  )                        {
                        let mm = this
                        //debugger
                        let listOfLines = Object.keys(mm.listOfSyncAsyncLines)
                        let lastLineNumber = listOfLines[listOfLines.length - 1]
                        for ( let lineNumber = 1 ; lineNumber <= lastLineNumber ; lineNumber ++ ) {
                            if (!mm.listOfSyncAsyncLines[lineNumber]) {
                                if (mm.listOfBreakpoints[lineNumber]) {
                                    delete mm.listOfBreakpoints[lineNumber]
                                    timeline_editor.session.clearBreakpoint(lineNumber - 1)
                                }
                            } else if (mm.listOfSyncAsyncLines[lineNumber].includes(false)) {
                                delete mm.listOfBreakpoints[lineNumber]
                                timeline_editor.session.clearBreakpoint(lineNumber - 1)
                            }
                        }

                    },
                    transformAST:                   async function  (  )                        {
                        let mm = this
                        await mm.createAST()
                        mm.rightPane = "transform_AST"


                        //
                        // add "await" to all function calls
                        //
                        mm.listOfSyncAsyncLines = {}
                        mm.transformedAST = estraverse.replace(
                            mm.codeAST
                            ,
                            {
                            leave: function (node, parent) {


                                if (
                                    ((node.body) && (Array.isArray(node.body)) && (parent.type != "Program"))
                                ) {
                                    node.body.flatMap(
                                        function(statement) {
                                            if (statement && statement.loc) {
                                                if (!mm.listOfSyncAsyncLines[statement.loc.start.line]) {
                                                    mm.listOfSyncAsyncLines[statement.loc.start.line] = [mm.isRunningInAsyncNode(statement, parent)]
                                                } else {
                                                    mm.listOfSyncAsyncLines[statement.loc.start.line].push(mm.isRunningInAsyncNode(statement, parent))
                                                }
                                            }
                                        }
                                    );
                                    node.body = node.body.flatMap(
                                        function(statement) {
                                            let isRunningInAsync = mm.isRunningInAsyncNode(node,parent)
                                            let asyncPrefix = mm.isRunningInAsyncNode(node,parent)?"async ":""
                                            let awaitPrefix = mm.isRunningInAsyncNode(node,parent)?"await ":""
                                            let yieldCode = null
                                            let varDecl = null
                                            //debugger
                                            if (statement && statement.loc) {
                                                let statementString = statement.type
                                                if (statementString == "VariableDeclaration"){
                                                    varDecl = statement.declarations[0].id.name
                                                }
                                                yieldCode = `(${asyncPrefix} function*() {
                                                        yield {
                                                                lineNumStart: ${statement.loc.start.line},
                                                                async:        ${mm.isRunningInAsyncNode(node,parent)}
                                                                }
                                                        while (mm.evalCodeAtBreakpoint && mm.codeToEvalAtBreakpoint) {
                                                            try {
                                                                mm.breakpointEvalResult = eval(mm.codeToEvalAtBreakpoint)
                                                            } catch (err) {
                                                                console.log ("Error in eval at breakpoint: " + JSON.stringify(err,null,2))
                                                                mm.breakpointEvalResult = null
                                                            } finally {
                                                                mm.evalCodeAtBreakpoint = false
                                                                yield {
                                                                    lineNumStart: ${statement.loc.start.line}
                                                                    }
                                                                yield
                                                            }
                                                        }
                                                        storeLineCallbackStatus(  ${statement.loc.start.line}  )
                                                        yield
                                                        mm.lastDebugSteppedIndex ++
                                                        if (mm.runToDebugStepIndex != null) {
                                                        } else {
                                                            let entry = {
                                                                id:             mm.lastDebugSteppedIndex,
                                                                code:           getNthLine(  mm.htmlInput  ,  ${statement.loc.start.line}  ),
                                                                type:           "${statementString}",
                                                                debuggableLine: ${isRunningInAsync},
                                                                lineNumStart:   ${statement.loc.start.line}
                                                            }
                                                            if ("${varDecl}" !== 'null') {
                                                                entry.varDecl = "${varDecl}"
                                                            }
                                                            mm.programDebugSteps.push(entry)
                                                            mm.scrollEnd()
                                                        }
                                                    })`
                                            } else {
                                                yieldCode = `(${asyncPrefix} function*() {
                                                        yield {
                                                                }
                                                    })`
                                            }
                                            let yieldCodeAfterAst = acorn.parse(yieldCode,{ ecmaVersion: 2021 });
                                            let yieldCodeAfter = yieldCodeAfterAst.body[0].expression.body.body
                                            return yieldCodeAfter.concat(statement)

                                        }
                                    );

                                }

                                // convert function to function* (generator function)
                                if (
                                        ((node.type === 'FunctionExpression') || (node.type === 'FunctionDeclaration' ))
                                   ) {



                                    // convert the function into a generator function
                                    if (node.generator == false) {
                                        node.generator = true
                                    }

                                    let asyncPrefix = node.async?"async ":""
                                    let awaitPrefix = node.async?"await ":""
                                    let pauseCode = node.async?
                                        `if (
                                                (
                                                    (
                                                        mm.runToDebugStepIndex == null
                                                    )
                                                    &&
                                                    (
                                                        mm.pauseAtNextLine
                                                        ||
                                                        mm.listOfBreakpoints[  mm.nextLineToExecute  ]
                                                    )
                                                )
                                                ||
                                                (
                                                    mm.runToDebugStepIndex == mm.lastDebugSteppedIndex
                                                )
                                            )
                                            {
                                                evalCodeAtBreakpoint = true
                                                mm.runToDebugStepIndex = null
                                                mm.pauseAtNextLine = false
                                                await mm.debuggerPause( );
                                            }
                                        `
                                        :
                                        ""

                                    let generatorCode =
                                        `(${asyncPrefix} function() {
                                            result = ${awaitPrefix} gen.next();
                                            let evalCodeAtBreakpoint = false
                                            while (!result.done) {
                                                mm.highlightStoppedLine(    {  result:  result  }  )
                                                mm.setNextLine(             {  result:  result  }  )

                                                ${pauseCode}
                                                ${awaitPrefix} gen.next(  {  evalCodeAtBreakpoint  }  );
                                                evalCodeAtBreakpoint = false
                                                result = ${awaitPrefix} gen.next();   // Move to the next yield
                                            }
                                            mm.highlightStoppedLine(    {  result:  result  }  )
                                            mm.setNextLine(             {  result:  result  }  )
                                            return result.value
                                        })()`

                                    let commandsAfterAst = acorn.parse(generatorCode,{ ecmaVersion: 2021 });
                                    let commandsAfter = commandsAfterAst.body[0].expression.callee.body.body


                                    // if this is like "function a() and not function () then move the declaration
                                    // of "a" up to the function

                                    let returnAst = {
                                        type:       "FunctionExpression",
                                        id:         node.type === 'FunctionDeclaration'  ?  node.id  :  null,
                                        expression: false,
                                        generator:  false,
                                        async:      node.async,
                                        params:     [],
                                        body:
                                            {
                                                type: "BlockStatement",
                                                body:
                                                    [
                                                        {
                                                            type: "VariableDeclaration",
                                                            kind: "let",
                                                            declarations:
                                                                [
                                                                    {
                                                                        type: "VariableDeclarator",
                                                                        id:
                                                                            {
                                                                                type: "Identifier",
                                                                                name: "gen"
                                                                            },
                                                                        init:
                                                                            {
                                                                                type:       "CallExpression",
                                                                                callee:     {
                                                                                    type:    "MemberExpression",
                                                                                    object:   node,
                                                                                    property: {
                                                                                        type: "Identifier",
                                                                                        name: "call"
                                                                                    },
                                                                                    computed: false,
                                                                                    optional: false
                                                                                },

                                                                                arguments:  [
                                                                                    {
                                                                                        type: "ThisExpression",

                                                                                    }
                                                                                ],
                                                                                optional:   false
                                                                            }
                                                                    }
                                                                ]
                                                        }
                                                    ].concat(commandsAfter)
                                            }
                                    }

                                    if (node.type === 'FunctionDeclaration') {
                                        node.id = null
                                    }


                                        return returnAst
                                }
                            },
                            enter: function (node, parent) {



                            },

                            keys: {
                                'AwaitExpression': ['argument']
                            }
                        });

                        await mm.clearUnreachableBreakpoints()
                    },
                    createDebugCode:                async function  (  )                        {
                        let mm = this
                        await mm.transformAST()
                        mm.rightPane = "debug_code"


                        //
                        // add "await" to all function calls
                        //
                        mm.debugCodeToEval = escodegen.generate(mm.transformedAST, {comment: false})
                    },
                    startDebugger:                  async function  (  args  )                  {
                        let mm = this
                        await mm.createDebugCode()
                        mm.rightPane = "debugger"
                        mm.pauseAtNextLine = false
                        mm.lastDebugSteppedIndex = -1
                        if (args && args.runToLine) {

                        } else {
                            mm.runToDebugStepIndex = null
                            mm.programDebugSteps = [  ]
                        }
                        //eval(mm.debugCodeToEval)
                        eval("(async function(){let promise = new Promise(async function(resolve) {" +
                                 mm.debugCodeToEval + "});await promise;" +
                            "                        console.log(\"CODE EVAL FINISHED\")"+
                            " })()")
                    },
                    stopDebugger:                   async function  (  )                        {
                        let mm = this
                        mm.rightPane = "canvas"
                        mm.programDebugSteps = [  ]
                        mm.lastDebugSteppedIndex = -1


//delete
                        document.getElementById('timeline_editor_html_element').addEventListener('mousemove',
                            function(event) {
                            const coords = timeline_editor.renderer.screenToTextCoordinates(event.clientX, event.clientY);
                            console.log('Row:', coords.row, 'Column:', coords.column);

                            if (coords.row ==  2) {
                                const hintElement = document.getElementById('hint');
                                hintElement.style.display = 'block';
                                hintElement.style.left = (event.clientX + 10) + 'px';
                                hintElement.style.top = (event.clientY + 10) + 'px';
                                //hintElement.style.display = 'none';
                            } else {
                                const hintElement = document.getElementById('hint');
                                hintElement.style.display = 'none';
                            }

                        });
//delete

                    },
                    stepOver:                       function        (  )                        {
                        let mm = this
                        mm.pauseAtNextLine = true
                        if (unpauseDebugger) {
                            unpauseDebugger()
                            unpauseDebugger = null
                        } else {
                            //console.log("Debugging ended")
                            //mm.rightPane = null
                        }
                    },
                    stepBack:                       async function  (  )                        {
                        let mm = this
                        if (mm.lastDebugSteppedIndex < 0) {
                            return
                        }
                        //debugger
                        mm.runToDebugStepIndex = mm.lastDebugSteppedIndex - 1
                        mm.lastDebugSteppedIndex --
                        let lastLine = mm.programDebugSteps.pop( )

                        while ((!lastLine.debuggableLine) && (mm.lastDebugSteppedIndex > -1)) {
                            lastLine = mm.programDebugSteps.pop( )
                            mm.runToDebugStepIndex = mm.lastDebugSteppedIndex - 1
                            mm.lastDebugSteppedIndex --
                        }
                        await mm.startDebugger(  {  runToLine: true  } )
                    },
                    evalAtBreakpoint:               function        (  )                        {
                        let mm = this
                        mm.evalCodeAtBreakpoint = true
                        mm.pauseAtNextLine = true
                        if (unpauseDebugger) {
                            unpauseDebugger()
                            unpauseDebugger = null
                        } else {
                            //console.log("Debugging ended")
                            //mm.rightPane = null
                        }
                    },
                    resumeDebugger:                 function        (  )                        {
                        let mm = this
                        mm.pauseAtNextLine = false
                        if (unpauseDebugger) {
                            unpauseDebugger()
                            unpauseDebugger = null

                        } else {
                            //console.log("Debugging ended")
                            //mm.rightPane = null
                        }
                    },
                    debuggerPause:                  async function  (  )                        {
                        let promise = new Promise(
                            function(resolve) {
                                unpauseDebugger = resolve
                                //setTimeout(resolve, 5000)
                            });
                        let ret = await promise
                        return ret
                    },
                    highlightStoppedLine:           function        (  {  result  }  )          {
                        let mm = this
                        if (result && result.value) {
                            let lineNum                 = result.value.lineNumStart
                            let line = mm.listOfSyncAsyncLines[lineNum]
                            let isSync = (!line) || line.includes(false)
                            //debugger
                            if (!isSync) {
                                timeline_editor.gotoLine(lineNum, 0, true);
                                timeline_editor.setHighlightActiveLine(true);
                            }
                        }
                    },
                    setNextLine:                    function        (  {  result  }  )          {
                        let mm = this
                        if (result && result.value) {
                            let lineNum                 = result.value.lineNumStart
                            mm.nextLineToExecute         = lineNum
                        }
                    }
                }
            })
        }
        function        mountDebuggerVueElement             (  )                                                {
            Vue.nextTick(function () {
                setTimeout(async function () {
                    //let vm = Vue.getCurrentInstance()
                    //debugger
                    //vueApp.refresh = 8
                    VueAppData = vueApp.mount("#vue_root_element")
                    console.log("main app mounted")

                }, 1000)
            })
        }
        function        storeVariableDeclaratorInDebugMode  (  stepNumber  ,  varName  ,  expressionValue  )    {
            dfdfd[stepNumber].varName = varName
            dfdfd[stepNumber].expressionValue = expressionValue
        }
        function        storeExpressionValueInDebugMode     (  stepNumber  ,  expressionValue  )                {

        }
        function        getExpressionValueInDebugMode       (  stepNumber  )                                    {

        }
        function        storeLineCallbackStatus             (  lineNumber  )                                    {
            const error = new Error();
            const stack = error.stack.toString();
            //debugger
            let inCallBack = stack.includes('Proxy.') || stack.includes('setTimeout') || stack.includes('setInterval');
            console.log("inCallBack: " +  lineNumber + " - " + inCallBack)
        }
        function        sleep                               (  ms  )                                            {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        async function  runAll                              (  )                                                {
            await init()
            await alaSqlStuff()
            await createDebuggerUI();
            await mountDebuggerVueElement();
        }
        function        getNthLine                          (  text  ,  n  )                                    {
            // Split the string by line breaks (\n)
            const lines = text.split('\n');

            // Check if the desired line number is within the range
            if (n >= 1 && n <= lines.length) {
                // Return the nth line (1-based index, so we use n-1)
                return lines[n - 1];
            } else {
                // Return null or an appropriate message if the line number is out of range
                return null;
            }
        }

        let timeline_editor     = null
        let globalWatchList     = {}
        let refData             = Vue.ref({a: 1})
        let refDebugCode        = Vue.ref("")
        let refOrigCode         = Vue.ref("")
        let refErrorMsg         = Vue.ref("Error ... ")
        let vueApp              = null
        let VueAppData          = null
        let unpauseDebugger     = null

        runAll();

    </script>
</html>
