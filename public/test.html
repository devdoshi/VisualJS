<html>
<head>
    <meta http-equiv="X-UA-Compatible"  content="IE=edge"                                                                                                                                                           />
    <meta name="viewport"               Content-Type="text/javascript; charset=utf-8" content="initial-scale=1.0, width=device-width, height=device-height, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta charset="UTF-8"                                                                                                                                                                                           />

    <script src="https://unpkg.com/vue@3.4.21/dist/vue.global.js"></script>
    <scriptvc src="https://unpkg.com/@vue/compat@3.1"></scriptvc>
    <script     src="https://cdn.jsdelivr.net/npm/alasql@4">                                                                                                                                                        </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/immer/9.0.21/immer.umd.production.min.js"></script>

    <script src="https://www.unpkg.com/esprima@4.0.1/dist/esprima.js"></script>
    <script>
        /*
Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
        /*jslint vars:false, bitwise:true*/
        /*jshint indent:4*/
        /*global exports:true, define:true*/
        (function (root, factory) {
            'use strict';

            // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
            // and plain browser loading,
            if (typeof define === 'function' && define.amd) {
                define(['exports'], factory);
            } else if (typeof exports !== 'undefined') {
                factory(exports);
            } else {
                factory((root.estraverse = {}));
            }
        }(this, function (exports) {
            'use strict';

            var Syntax,
                isArray,
                VisitorOption,
                VisitorKeys,
                objectCreate,
                objectKeys,
                BREAK,
                SKIP,
                REMOVE;

            function ignoreJSHintError() { }

            isArray = Array.isArray;
            if (!isArray) {
                isArray = function isArray(array) {
                    return Object.prototype.toString.call(array) === '[object Array]';
                };
            }

            function deepCopy(obj) {
                var ret = {}, key, val;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        val = obj[key];
                        if (typeof val === 'object' && val !== null) {
                            ret[key] = deepCopy(val);
                        } else {
                            ret[key] = val;
                        }
                    }
                }
                return ret;
            }

            function shallowCopy(obj) {
                var ret = {}, key;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        ret[key] = obj[key];
                    }
                }
                return ret;
            }
            ignoreJSHintError(shallowCopy);

            // based on LLVM libc++ upper_bound / lower_bound
            // MIT License

            function upperBound(array, func) {
                var diff, len, i, current;

                len = array.length;
                i = 0;

                while (len) {
                    diff = len >>> 1;
                    current = i + diff;
                    if (func(array[current])) {
                        len = diff;
                    } else {
                        i = current + 1;
                        len -= diff + 1;
                    }
                }
                return i;
            }

            function lowerBound(array, func) {
                var diff, len, i, current;

                len = array.length;
                i = 0;

                while (len) {
                    diff = len >>> 1;
                    current = i + diff;
                    if (func(array[current])) {
                        i = current + 1;
                        len -= diff + 1;
                    } else {
                        len = diff;
                    }
                }
                return i;
            }
            ignoreJSHintError(lowerBound);

            objectCreate = Object.create || (function () {
                function F() { }

                return function (o) {
                    F.prototype = o;
                    return new F();
                };
            })();

            objectKeys = Object.keys || function (o) {
                var keys = [], key;
                for (key in o) {
                    keys.push(key);
                }
                return keys;
            };

            function extend(to, from) {
                objectKeys(from).forEach(function (key) {
                    to[key] = from[key];
                });
                return to;
            }

            Syntax = {
                AssignmentExpression: 'AssignmentExpression',
                ArrayExpression: 'ArrayExpression',
                ArrayPattern: 'ArrayPattern',
                ArrowFunctionExpression: 'ArrowFunctionExpression',
                BlockStatement: 'BlockStatement',
                BinaryExpression: 'BinaryExpression',
                BreakStatement: 'BreakStatement',
                CallExpression: 'CallExpression',
                CatchClause: 'CatchClause',
                ClassBody: 'ClassBody',
                ClassDeclaration: 'ClassDeclaration',
                ClassExpression: 'ClassExpression',
                ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
                ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
                ConditionalExpression: 'ConditionalExpression',
                ContinueStatement: 'ContinueStatement',
                DebuggerStatement: 'DebuggerStatement',
                DirectiveStatement: 'DirectiveStatement',
                DoWhileStatement: 'DoWhileStatement',
                EmptyStatement: 'EmptyStatement',
                ExportBatchSpecifier: 'ExportBatchSpecifier',
                ExportDeclaration: 'ExportDeclaration',
                ExportSpecifier: 'ExportSpecifier',
                ExpressionStatement: 'ExpressionStatement',
                ForStatement: 'ForStatement',
                ForInStatement: 'ForInStatement',
                ForOfStatement: 'ForOfStatement',
                FunctionDeclaration: 'FunctionDeclaration',
                FunctionExpression: 'FunctionExpression',
                GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
                Identifier: 'Identifier',
                IfStatement: 'IfStatement',
                ImportDeclaration: 'ImportDeclaration',
                ImportDefaultSpecifier: 'ImportDefaultSpecifier',
                ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
                ImportSpecifier: 'ImportSpecifier',
                Literal: 'Literal',
                LabeledStatement: 'LabeledStatement',
                LogicalExpression: 'LogicalExpression',
                MemberExpression: 'MemberExpression',
                MethodDefinition: 'MethodDefinition',
                ModuleSpecifier: 'ModuleSpecifier',
                NewExpression: 'NewExpression',
                ObjectExpression: 'ObjectExpression',
                ObjectPattern: 'ObjectPattern',
                Program: 'Program',
                Property: 'Property',
                ReturnStatement: 'ReturnStatement',
                SequenceExpression: 'SequenceExpression',
                SpreadElement: 'SpreadElement',
                SwitchStatement: 'SwitchStatement',
                SwitchCase: 'SwitchCase',
                TaggedTemplateExpression: 'TaggedTemplateExpression',
                TemplateElement: 'TemplateElement',
                TemplateLiteral: 'TemplateLiteral',
                ThisExpression: 'ThisExpression',
                ThrowStatement: 'ThrowStatement',
                TryStatement: 'TryStatement',
                UnaryExpression: 'UnaryExpression',
                UpdateExpression: 'UpdateExpression',
                VariableDeclaration: 'VariableDeclaration',
                VariableDeclarator: 'VariableDeclarator',
                WhileStatement: 'WhileStatement',
                WithStatement: 'WithStatement',
                YieldExpression: 'YieldExpression'
            };

            VisitorKeys = {
                AssignmentExpression: ['left', 'right'],
                ArrayExpression: ['elements'],
                ArrayPattern: ['elements'],
                ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
                BlockStatement: ['body'],
                BinaryExpression: ['left', 'right'],
                BreakStatement: ['label'],
                CallExpression: ['callee', 'arguments'],
                CatchClause: ['param', 'body'],
                ClassBody: ['body'],
                ClassDeclaration: ['id', 'body', 'superClass'],
                ClassExpression: ['id', 'body', 'superClass'],
                ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
                ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
                ConditionalExpression: ['test', 'consequent', 'alternate'],
                ContinueStatement: ['label'],
                DebuggerStatement: [],
                DirectiveStatement: [],
                DoWhileStatement: ['body', 'test'],
                EmptyStatement: [],
                ExportBatchSpecifier: [],
                ExportDeclaration: ['declaration', 'specifiers', 'source'],
                ExportSpecifier: ['id', 'name'],
                ExpressionStatement: ['expression'],
                ForStatement: ['init', 'test', 'update', 'body'],
                ForInStatement: ['left', 'right', 'body'],
                ForOfStatement: ['left', 'right', 'body'],
                FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
                FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
                GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
                Identifier: [],
                IfStatement: ['test', 'consequent', 'alternate'],
                ImportDeclaration: ['specifiers', 'source'],
                ImportDefaultSpecifier: ['id'],
                ImportNamespaceSpecifier: ['id'],
                ImportSpecifier: ['id', 'name'],
                Literal: [],
                LabeledStatement: ['label', 'body'],
                LogicalExpression: ['left', 'right'],
                MemberExpression: ['object', 'property'],
                MethodDefinition: ['key', 'value'],
                ModuleSpecifier: [],
                NewExpression: ['callee', 'arguments'],
                ObjectExpression: ['properties'],
                ObjectPattern: ['properties'],
                Program: ['body'],
                Property: ['key', 'value'],
                ReturnStatement: ['argument'],
                SequenceExpression: ['expressions'],
                SpreadElement: ['argument'],
                SwitchStatement: ['discriminant', 'cases'],
                SwitchCase: ['test', 'consequent'],
                TaggedTemplateExpression: ['tag', 'quasi'],
                TemplateElement: [],
                TemplateLiteral: ['quasis', 'expressions'],
                ThisExpression: [],
                ThrowStatement: ['argument'],
                TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
                UnaryExpression: ['argument'],
                UpdateExpression: ['argument'],
                VariableDeclaration: ['declarations'],
                VariableDeclarator: ['id', 'init'],
                WhileStatement: ['test', 'body'],
                WithStatement: ['object', 'body'],
                YieldExpression: ['argument']
            };

            // unique id
            BREAK = {};
            SKIP = {};
            REMOVE = {};

            VisitorOption = {
                Break: BREAK,
                Skip: SKIP,
                Remove: REMOVE
            };

            function Reference(parent, key) {
                this.parent = parent;
                this.key = key;
            }

            Reference.prototype.replace = function replace(node) {
                this.parent[this.key] = node;
            };

            Reference.prototype.remove = function remove() {
                if (isArray(this.parent)) {
                    this.parent.splice(this.key, 1);
                    return true;
                } else {
                    this.replace(null);
                    return false;
                }
            };

            function Element(node, path, wrap, ref) {
                this.node = node;
                this.path = path;
                this.wrap = wrap;
                this.ref = ref;
            }

            function Controller() { }

            // API:
            // return property path array from root to current node
            Controller.prototype.path = function path() {
                var i, iz, j, jz, result, element;

                function addToPath(result, path) {
                    if (isArray(path)) {
                        for (j = 0, jz = path.length; j < jz; ++j) {
                            result.push(path[j]);
                        }
                    } else {
                        result.push(path);
                    }
                }

                // root node
                if (!this.__current.path) {
                    return null;
                }

                // first node is sentinel, second node is root element
                result = [];
                for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
                    element = this.__leavelist[i];
                    addToPath(result, element.path);
                }
                addToPath(result, this.__current.path);
                return result;
            };

            // API:
            // return array of parent elements
            Controller.prototype.parents = function parents() {
                var i, iz, result;

                // first node is sentinel
                result = [];
                for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
                    result.push(this.__leavelist[i].node);
                }

                return result;
            };

            // API:
            // return current node
            Controller.prototype.current = function current() {
                return this.__current.node;
            };

            Controller.prototype.__execute = function __execute(callback, element) {
                var previous, result;

                result = undefined;

                previous  = this.__current;
                this.__current = element;
                this.__state = null;
                if (callback) {
                    result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
                }
                this.__current = previous;

                return result;
            };

            // API:
            // notify control skip / break
            Controller.prototype.notify = function notify(flag) {
                this.__state = flag;
            };

            // API:
            // skip child nodes of current node
            Controller.prototype.skip = function () {
                this.notify(SKIP);
            };

            // API:
            // break traversals
            Controller.prototype['break'] = function () {
                this.notify(BREAK);
            };

            // API:
            // remove node
            Controller.prototype.remove = function () {
                this.notify(REMOVE);
            };

            Controller.prototype.__initialize = function(root, visitor) {
                this.visitor = visitor;
                this.root = root;
                this.__worklist = [];
                this.__leavelist = [];
                this.__current = null;
                this.__state = null;
                this.__fallback = visitor.fallback === 'iteration';
                this.__keys = VisitorKeys;
                if (visitor.keys) {
                    this.__keys = extend(objectCreate(this.__keys), visitor.keys);
                }
            };

            function isNode(node) {
                if (node == null) {
                    return false;
                }
                return typeof node === 'object' && typeof node.type === 'string';
            }

            function isProperty(nodeType, key) {
                return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
            }

            Controller.prototype.traverse = function traverse(root, visitor) {
                var worklist,
                    leavelist,
                    element,
                    node,
                    nodeType,
                    ret,
                    key,
                    current,
                    current2,
                    candidates,
                    candidate,
                    sentinel;

                this.__initialize(root, visitor);

                sentinel = {};

                // reference
                worklist = this.__worklist;
                leavelist = this.__leavelist;

                // initialize
                worklist.push(new Element(root, null, null, null));
                leavelist.push(new Element(null, null, null, null));

                while (worklist.length) {
                    element = worklist.pop();

                    if (element === sentinel) {
                        element = leavelist.pop();

                        ret = this.__execute(visitor.leave, element);

                        if (this.__state === BREAK || ret === BREAK) {
                            return;
                        }
                        continue;
                    }

                    if (element.node) {

                        ret = this.__execute(visitor.enter, element);

                        if (this.__state === BREAK || ret === BREAK) {
                            return;
                        }

                        worklist.push(sentinel);
                        leavelist.push(element);

                        if (this.__state === SKIP || ret === SKIP) {
                            continue;
                        }

                        node = element.node;
                        nodeType = element.wrap || node.type;
                        candidates = this.__keys[nodeType];
                        if (!candidates) {
                            if (this.__fallback) {
                                candidates = objectKeys(node);
                            } else {
                                throw new Error('Unknown node type ' + nodeType + '.');
                            }
                        }

                        current = candidates.length;
                        while ((current -= 1) >= 0) {
                            key = candidates[current];
                            candidate = node[key];
                            if (!candidate) {
                                continue;
                            }

                            if (isArray(candidate)) {
                                current2 = candidate.length;
                                while ((current2 -= 1) >= 0) {
                                    if (!candidate[current2]) {
                                        continue;
                                    }
                                    if (isProperty(nodeType, candidates[current])) {
                                        element = new Element(candidate[current2], [key, current2], 'Property', null);
                                    } else if (isNode(candidate[current2])) {
                                        element = new Element(candidate[current2], [key, current2], null, null);
                                    } else {
                                        continue;
                                    }
                                    worklist.push(element);
                                }
                            } else if (isNode(candidate)) {
                                worklist.push(new Element(candidate, key, null, null));
                            }
                        }
                    }
                }
            };

            Controller.prototype.replace = function replace(root, visitor) {
                function removeElem(element) {
                    var i,
                        key,
                        nextElem,
                        parent;

                    if (element.ref.remove()) {
                        // When the reference is an element of an array.
                        key = element.ref.key;
                        parent = element.ref.parent;

                        // If removed from array, then decrease following items' keys.
                        i = worklist.length;
                        while (i--) {
                            nextElem = worklist[i];
                            if (nextElem.ref && nextElem.ref.parent === parent) {
                                if  (nextElem.ref.key < key) {
                                    break;
                                }
                                --nextElem.ref.key;
                            }
                        }
                    }
                }

                var worklist,
                    leavelist,
                    node,
                    nodeType,
                    target,
                    element,
                    current,
                    current2,
                    candidates,
                    candidate,
                    sentinel,
                    outer,
                    key;

                this.__initialize(root, visitor);

                sentinel = {};

                // reference
                worklist = this.__worklist;
                leavelist = this.__leavelist;

                // initialize
                outer = {
                    root: root
                };
                element = new Element(root, null, null, new Reference(outer, 'root'));
                worklist.push(element);
                leavelist.push(element);

                while (worklist.length) {
                    element = worklist.pop();

                    if (element === sentinel) {
                        element = leavelist.pop();

                        target = this.__execute(visitor.leave, element);

                        // node may be replaced with null,
                        // so distinguish between undefined and null in this place
                        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                            // replace
                            element.ref.replace(target);
                        }

                        if (this.__state === REMOVE || target === REMOVE) {
                            removeElem(element);
                        }

                        if (this.__state === BREAK || target === BREAK) {
                            return outer.root;
                        }
                        continue;
                    }

                    target = this.__execute(visitor.enter, element);

                    // node may be replaced with null,
                    // so distinguish between undefined and null in this place
                    if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                        // replace
                        element.ref.replace(target);
                        element.node = target;
                    }

                    if (this.__state === REMOVE || target === REMOVE) {
                        removeElem(element);
                        element.node = null;
                    }

                    if (this.__state === BREAK || target === BREAK) {
                        return outer.root;
                    }

                    // node may be null
                    node = element.node;
                    if (!node) {
                        continue;
                    }

                    worklist.push(sentinel);
                    leavelist.push(element);

                    if (this.__state === SKIP || target === SKIP) {
                        continue;
                    }

                    nodeType = element.wrap || node.type;
                    candidates = this.__keys[nodeType];
                    if (!candidates) {
                        if (this.__fallback) {
                            candidates = objectKeys(node);
                        } else {
                            throw new Error('Unknown node type ' + nodeType + '.');
                        }
                    }

                    current = candidates.length;
                    while ((current -= 1) >= 0) {
                        key = candidates[current];
                        candidate = node[key];
                        if (!candidate) {
                            continue;
                        }

                        if (isArray(candidate)) {
                            current2 = candidate.length;
                            while ((current2 -= 1) >= 0) {
                                if (!candidate[current2]) {
                                    continue;
                                }
                                if (isProperty(nodeType, candidates[current])) {
                                    element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                                } else if (isNode(candidate[current2])) {
                                    element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                                } else {
                                    continue;
                                }
                                worklist.push(element);
                            }
                        } else if (isNode(candidate)) {
                            worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                        }
                    }
                }

                return outer.root;
            };

            function traverse(root, visitor) {
                var controller = new Controller();
                return controller.traverse(root, visitor);
            }

            function replace(root, visitor) {
                var controller = new Controller();
                return controller.replace(root, visitor);
            }

            function extendCommentRange(comment, tokens) {
                var target;

                target = upperBound(tokens, function search(token) {
                    return token.range[0] > comment.range[0];
                });

                comment.extendedRange = [comment.range[0], comment.range[1]];

                if (target !== tokens.length) {
                    comment.extendedRange[1] = tokens[target].range[0];
                }

                target -= 1;
                if (target >= 0) {
                    comment.extendedRange[0] = tokens[target].range[1];
                }

                return comment;
            }

            function attachComments(tree, providedComments, tokens) {
                // At first, we should calculate extended comment ranges.
                var comments = [], comment, len, i, cursor;

                if (!tree.range) {
                    throw new Error('attachComments needs range information');
                }

                // tokens array is empty, we attach comments to tree as 'leadingComments'
                if (!tokens.length) {
                    if (providedComments.length) {
                        for (i = 0, len = providedComments.length; i < len; i += 1) {
                            comment = deepCopy(providedComments[i]);
                            comment.extendedRange = [0, tree.range[0]];
                            comments.push(comment);
                        }
                        tree.leadingComments = comments;
                    }
                    return tree;
                }

                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
                }

                // This is based on John Freeman's implementation.
                cursor = 0;
                traverse(tree, {
                    enter: function (node) {
                        var comment;

                        while (cursor < comments.length) {
                            comment = comments[cursor];
                            if (comment.extendedRange[1] > node.range[0]) {
                                break;
                            }

                            if (comment.extendedRange[1] === node.range[0]) {
                                if (!node.leadingComments) {
                                    node.leadingComments = [];
                                }
                                node.leadingComments.push(comment);
                                comments.splice(cursor, 1);
                            } else {
                                cursor += 1;
                            }
                        }

                        // already out of owned node
                        if (cursor === comments.length) {
                            return VisitorOption.Break;
                        }

                        if (comments[cursor].extendedRange[0] > node.range[1]) {
                            return VisitorOption.Skip;
                        }
                    }
                });

                cursor = 0;
                traverse(tree, {
                    leave: function (node) {
                        var comment;

                        while (cursor < comments.length) {
                            comment = comments[cursor];
                            if (node.range[1] < comment.extendedRange[0]) {
                                break;
                            }

                            if (node.range[1] === comment.extendedRange[0]) {
                                if (!node.trailingComments) {
                                    node.trailingComments = [];
                                }
                                node.trailingComments.push(comment);
                                comments.splice(cursor, 1);
                            } else {
                                cursor += 1;
                            }
                        }

                        // already out of owned node
                        if (cursor === comments.length) {
                            return VisitorOption.Break;
                        }

                        if (comments[cursor].extendedRange[0] > node.range[1]) {
                            return VisitorOption.Skip;
                        }
                    }
                });

                return tree;
            }

            exports.version = '1.7.1';
            exports.Syntax = Syntax;
            exports.traverse = traverse;
            exports.replace = replace;
            exports.attachComments = attachComments;
            exports.VisitorKeys = VisitorKeys;
            exports.VisitorOption = VisitorOption;
            exports.Controller = Controller;
        }));
        /* vim: set sw=4 ts=4 et tw=80 : */
    </script>

    <body>
        <div>
            <div id="injected_id"></div>
            <br>
            <br>
            <br>
            <br>
            <br>
            Standard HTML and JS below
            <br>
            <b>HI THERE!</b>
            <div id="tele" style="border: 1px solid black">TELE:</div>
            <div id="tele2" style="border: 1px solid black">TELE2:</div>
        </div>

        <div style="margin-top:200px">
            Inside VueJS 2 below
            <div id="rootel"></div>
        </div>
    </body>



    <script>
        function        getDebugCode                        (  blockName  ,  trcode2  ,  args  ) {
            return trcode2

            let _b = esprima.parse(trcode2,{tolerant: true , loc:true, range: true, attachComment: false})
            let line = -1
            let varsToAdd = {}
            let skipFirstAndLastLine = false
            let numLinesToSkip = 0
            if (isValidObject(args)) {
                if (args.skipFirstAndLastLine){
                    skipFirstAndLastLine=true
                    numLinesToSkip = 1
                }
            }

            if (uiDebuggerOn) {
                estraverse.traverse(_b, {
                    enter: function (node, parent) {
                        //
                        // add the line numbers
                        //
                        if (
                            (node.type == "ExpressionStatement")
                            ||
                            (node.type == "VariableDeclaration")
                            ||
                            (node.type == "AssignmentExpression")
                        ) {
                            if (parent) {
                                if ((node.loc.start.line - numLinesToSkip) > line) {
                                    line = (node.loc.start.line - numLinesToSkip)

                                    if (line > 0) {
                                        let newLine = "logExecutionPoint('" + blockName + "', " + line +",'" + JSON.stringify(node.type) + "');"
                                        let newNode = esprima.parse(newLine)

                                        for (let rr = 0; rr < parent.body.length; rr++){
                                            if (parent.body[rr] == node) {
                                                parent.body.splice(rr, 0, newNode);
                                                break
                                            }
                                        }





                                        //
                                        // vars
                                        //
                                        if (node.type == "VariableDeclaration") {
                                            if (node.declarations[0].init) {
                                                //alert(`let ${node.declarations[0].id.name} = ${node.declarations[0].init.value}`)
                                                let varNameToUse = node.declarations[0].id.name
                                                if (node.kind == "var") {
                                                    if (isValidObject(varNameToUse) && varNameToUse.indexOf("undefined")==-1){
                                                        let newLine = "logVarBefore('" + blockName + "', " + node.loc.start.line + ",'" +
                                                            varNameToUse + "', " + varNameToUse + ");"
                                                        let newNode = esprima.parse(newLine)
                                                    }
                                                }
                                                varsToAdd[varNameToUse] = {}

                                                let newLineAfter = "logVarAfter('" + blockName + "', " + node.loc.start.line + ",'" +
                                                    varNameToUse + "'," + varNameToUse + ");"
                                                let newNodeAfter = esprima.parse(newLineAfter)

                                                let logWatchVarsCode = `for (let _uu=0; _uu<Object.keys(globalWatchList).length; _uu++){try { let _vName = Object.keys(globalWatchList)[_uu];if (isValidObject(_vName)){ addWatchPoint(_vName, eval(_vName) ) }} catch(_err){}}`
                                                let logWatchVarsNode = esprima.parse(logWatchVarsCode)

                                                for (let rr = 0; rr < parent.body.length; rr++) {
                                                    if (parent.body[rr] == node) {
                                                        parent.body.splice(rr + 1, 0, logWatchVarsNode);
                                                        parent.body.splice(rr + 1, 0, newNodeAfter);
                                                        parent.body.splice(rr, 0, newNode);
                                                        break;
                                                    }
                                                }
                                            }
                                        }



                                        if ((node.type == "ExpressionStatement") && node.expression) {
                                            if (node.expression.type == "CallExpression") {
                                                let logWatchVarsCode = `for (let _uu=0; _uu<Object.keys(globalWatchList).length; _uu++){try { let _vName = Object.keys(globalWatchList)[_uu];if (isValidObject(_vName)){ addWatchPoint(_vName, eval(_vName) ) }} catch(_err){}}`
                                                let logWatchVarsNode = esprima.parse(logWatchVarsCode)

                                                for (let rr=0; rr<parent.body.length; rr++){
                                                    if (parent.body[rr] == node) {
                                                        if (logWatchVarsNode){
                                                            parent.body.splice(rr + 1, 0, logWatchVarsNode);
                                                        }
                                                        break;   }}}}




                                        if ((node.type == "ExpressionStatement") && node.expression) {
                                            if ((node.expression.type == "AssignmentExpression") &&
                                                (node.expression.operator == "=")) {
                                                let varName = node.expression.left.name
                                                if (isValidObject(varName) && varName.indexOf("undefined") == -1) {
                                                    if (!isValidObject(varName)) {
                                                        if (node.expression.left.object.type == "ThisExpression") {
                                                            varName = "this." + node.expression.left.property.name
                                                        } else if (node.expression.left.type == "MemberExpression") {
                                                            varName = node.expression.left.object.name
                                                            if (node.expression.left.property.type == "Identifier") {
                                                                varName += "." + node.expression.left.property.name
                                                            }
                                                        }
                                                    }
                                                    varsToAdd[varName] = {}


                                                    let newLine = "logVarBefore('" + blockName + "', " + node.loc.start.line + ",'" +
                                                        varName + "', " + varName + ");"
                                                    let newNode = esprima.parse(newLine)

                                                    let newLineAfter = "logVarAfter('" + blockName + "', " + node.loc.start.line + ",'" +
                                                        varName + "', " + varName + ");"
                                                    let newNodeAfter = esprima.parse(newLineAfter)

                                                    let logWatchVarsCode = `for (let _uu=0; _uu<Object.keys(globalWatchList).length; _uu++){try { let _vName = Object.keys(globalWatchList)[_uu];if (isValidObject(_vName)){ addWatchPoint(_vName, eval(_vName) ) }} catch(_err){}}`
                                                    let logWatchVarsNode = esprima.parse(logWatchVarsCode)

                                                    for (let rr = 0; rr < parent.body.length; rr++) {
                                                        if (parent.body[rr] == node) {
                                                            if (logWatchVarsNode) {
                                                                parent.body.splice(rr + 1, 0, logWatchVarsNode);
                                                            }
                                                            if (newNodeAfter) {
                                                                parent.body.splice(rr + 1, 0, newNodeAfter);
                                                            }
                                                            parent.body.splice(rr, 0, newNode);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }


                                    }
                                }
                            }
                        }






                    },
                    leave: function (node, parent) {
                    },

                    keys: {
                        'AwaitExpression': ['argument']
                    }
                });

                for ( let fds = 0 ; fds < Object.keys(varsToAdd).length ; fds ++ ) {
                    let nnn = Object.keys(varsToAdd)[fds]
                    globalWatchList[nnn]={
                        viewer: ""
                    }
                }
            }


            //
            // add "await" to all function calls
            //
            estraverse.replace(_b, {
                leave: function (node, parent) {
                    if (node.type === 'CallExpression') {
                        //debugger
                        //if (node && node.expression && node.expression.async) {
                        return {
                            type:       'AwaitExpression',
                            argument:   node
                        };
                        //};
                    }
                },

                keys: {
                    'AwaitExpression': ['argument']
                }
            });

            let debugCode = escodegen.generate(_b, {comment: false})





            if (uiDebuggerOn) {
                executionCode[blockName] = {}
                executionCode[blockName].debug_code = debugCode
                if (numLinesToSkip > 0) {
                    let indexOfFirst = trcode2.indexOf("\n")
                    if (indexOfFirst != -1) {
                        trcode2 = trcode2.substring(indexOfFirst + numLinesToSkip)
                    }

                    let indexOfLast = trcode2.lastIndexOf("\n")
                    if (indexOfLast != -1) {
                        trcode2 = trcode2.substring(0, indexOfLast)
                    }
                }

                trcode2 = trcode2.toString().replaceAll("await sqlRx[(][^,]*,[^,]*,", "sql(")
                trcode2 = trcode2.toString().replaceAll("await sqlRx1[(][^,]*,[^,]*,", "sql1(")
                trcode2 = trcode2.toString().replaceAll("await sqlRxFirstCol[(][^,]*,[^,]*,", "sqlFirstCol(")
                trcode2 = trcode2.toString().replaceAll("await sqlRxFirstCol1[(][^,]*,[^,]*,", "sqlFirstCol1(")

                executionCode[blockName].code = trcode2
                executionCode[blockName].start = startTimelineTop
                startTimelineTop += trcode2.length
            }

            return debugCode
        }

        alasql("CREATE TABLE test (language INT, hello STRING)");
        alasql.fn.verify = function(r) {
            return true; // Do not insert on this number
        };
        alasql('CREATE TRIGGER mytrigger BEFORE INSERT ON test verify');
        alasql("INSERT INTO test VALUES (1,'Hello!')");
        alasql("INSERT INTO test VALUES (2,'Aloha!')");
        alasql("INSERT INTO test VALUES (3,'Bonjour!')");
        console.log( alasql("SELECT * FROM test WHERE language > 1") );

        alasql("create view testview (name) as select * from test ;")
        alasql.fn.verify2 = function(r) {
            return true; // Do not insert on this number
        };
        alasql('CREATE TRIGGER mytrigger AFTER update ON testview verify2');
        alasql("INSERT INTO test VALUES (4,'Velkommen!')");
        console.log( alasql("SELECT * FROM testview ") );

        const baseState = [
            {
                title: "Learn TypeScript",
                done: true
            },
            {
                title: "Try Immer",
                done: false
            }
        ]


        let dataImmerData = baseState

        let vueApp = Vue.createApp(
                {
                    el: "#rootel",
                    template:   `
                        <div style="">
                            <br>
                            <br>
                        {{dataImmer}}
                            <br>
                            <br>
                                WE ARE IN THE MATRIX...
                                <br>
                                showItem := {{showItem}}
                                <div v-if='showItem'>
                                    <b><component v-bind:refresh='refresh' :is='"UserList"' ></component></b>
                                </div>
                                <div v-if='showItem2'>
                                    <b><component v-bind:refresh='refresh' :is='"UserList2"' v-bind:teleport_id='teleportId' ></component></b>
                                </div>
                                <br>
                                <button style="height: 050px;width:050px;" v-on:click="createItem()" >Create item</button>
                                <button style="height: 050px;width:050px;" v-on:click="showItemf()" >Show</button>

                                <button style="height: 050px;width:100px;" v-on:click="refreshAll()" >Refresh</button>

                                <button style="height: 050px;width:050px;" v-on:click="createItem2()" >Create item 2</button>
                                <button style="height: 050px;width:050px;" v-on:click="showItemf2()" >Show</button>

                                <button style="height: 050px;width:100px;" v-on:click="switchTeleport()" >switch Teleport</button>

                                <button style="height: 050px;width:100px;" v-on:click="runDebugger()" >Run debugger</button>

                                <button style="height: 050px;width:100px;" v-on:click="mutate()" >Mutate</button>
                        </div>`,
                    data: function() {
                        return {
                            refresh: 0,
                            showItem: false,
                            showItem2: false,
                            teleportId: "tele",
                            dataImmer:  dataImmerData
                        }
                    },
                    mounted:    async function() {
                    },
                    methods: {
                        switchTeleport: function(){
                            this.teleportId = "tele2"
                        },
                        createItem: async function () {

                            vueApp.component("UserList",
                                {
                                    name: "UserList",
                                    template:   `
                                        <div style="margin-top: 70px;">
                                            <br>
                                                I am a component 5...
                                                <Teleport to="#tele">
                                                  <div >
                                                    component COntent teleported
                                                  </div>
                                                </Teleport>

                                        </div>`
                                })
                            this.refresh ++
                            console.log("Loaded user component")
                        },
                        refreshAll: async function () {
                            this.refresh ++
                            console.log("Refreshed app")
                        },
                        showItemf: async function () {
                            this.showItem = !this.showItem
                            console.log("Showed item")
                        },
                        createItem2: async function () {

                            vueApp.component("UserList2",
                                {
                                    name: "UserList2",
                                    props: ["teleport_id"],
                                    template:   `
                                        <div style="margin-top: 70px;">
                                            <br>
                                                I am a component 6... ({{teleport_id}}
                                                <Teleport v-bind:to='"#" + teleport_id'>
                                                  <div >
                                                    component COntent teleported 2
                                                  </div>
                                                </Teleport>

                                        </div>`
                                })
                            this.refresh ++
                            console.log("Loaded user component")
                        },
                        showItemf2: async function () {
                            debugger
                            this.showItem2 = !this.showItem2
                            console.log("Showed item 2")
                        }
                        ,
                        evalInContext: function (js, contextAsScope) {
                            //# Return the results of the in-line anonymous function we .call with the passed context
                            return function() { with(this) { return eval(js); }; }.call(contextAsScope);
                        },
                        runDebugger:  async function () {

                            function* foo () {
                                while (true) {
                                    let command = yield;
                                    console.log("Running command: " + command)
                                    if (command=="STOP") {
                                        return
                                    }
                                    eval(command)
                                }
                                console.log("foo done")
                            };
                            let gen=foo()
                            gen.next()
                            gen.next("let a = 12;console.log(a);")
                            //gen.next("console.log(a)")
                            gen.next("STOP")

                            console.log(" ------------------------------------------------- ")

                            let context = {}
                            this.evalInContext( "this.a = 10"         , context )
                            this.evalInContext( "console.log(this.a)" , context )
                        }
                        ,
                        mutate:  async function ()
                        {
                            let mm=this
                            debugger
                            const nextState = immer.produce(mm.dataImmer, draft => {
                                draft[1].done = true
                                draft.push({title: "Tweet about it"})
                            })
                            mm.dataImmer = nextState
                        }
                    }
                })

        Vue.nextTick(function(){
            setTimeout(async function() {
                //let vm = Vue.getCurrentInstance()
                //debugger
                //vueApp.refresh = 8
                vueApp.mount("#rootel")
                console.log("main app mounted")

            },1000)
        })


        let injectedCode = `
Vue.createApp(
            {
                el: "#injected_id",
                template: "injected code"
            })

        `

        let debugInjectedCode = getDebugCode("Vue code", injectedCode)
        console.log("DEBUG CODE: ")
        console.log(debugInjectedCode)
        let injectedVueApp = eval(debugInjectedCode)
        injectedVueApp.mount("#injected_id")



    </script>

</html>
